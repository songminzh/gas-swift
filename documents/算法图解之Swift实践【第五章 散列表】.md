[TOC]
## 何为散列表
散列表即哈希表（Hash Table），也即我们常用的字典类型。
散列表是能够通过给定的关键字的值直接访问到具体对应的值的一个数据结构。也就是说，把关键字映射到一个表中的位置来直接访问记录，以加快访问速度。
通常，我们把这个关键字称为 Key，把对应的记录称为 Value，所以也可以说是通过 Key 访问一个映射表来得到 Value 的地址。

## 散列函数
通过key-value构成的映射函数叫作散列函数或者哈希函数，存放记录的数组叫作散列表。
散列函数必须满足以下条件：
* 它必须是一致的。例如，在将字符串作为key，数字作为value的散列函数中，假设你输入apple时得到的是4，那么每次输入apple时，得到的都必须为4。如果不是这样，散列表将毫无用处。
* 它应将不同的输入映射到不同的数字。例如，如果一个散列函数不管输入是什么都返回1，它就不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。
* 散列函数知道数组有多大，只返回有效的索引。如果数组包含5个元素，散列函数就不会返回无效索引100。
结合使用散列函数和数组创建了一种被称为**散列表**的数据结构。
Swift提供的散列表实现为**字典**，我们可以使用Dictionary来创建散列表。
```swift
var book: [String: Int] = [:] // 创建了一个空的 [String: Int] 字典
book["apple"] = 3 // 苹果的单价是3元
book["milk"] = 6 // 牛奶的单价是6元
book["avocado"] = 4 // 鳄梨的单价是4元
print(book)

>>> ["apple": 3, "milk": 6, "avocado": 4]
print(book["avocado"]!) // 读取梨的价格并打印
>>> 4
```
## 练习一
对于同样的输入，散列表必须返回同样的输出，这一点很重要。如果不是这样的，就无法找到你在散列表中添加的元素！

请问下面哪些散列函数是一致的？
5.1 f(x) = 1 <------无论输入是什么，都返回1
> 显然一致

5.2 f(x) = rand() <------每次都返回一个随机数
> 显然不一致

5.3 f(x) = next_empty_slot() <------返回散列表中下一个空位置的索引
> 不一致 散列表中下一个空位置索引会发生变化，因此不一致

5.4 f(x) = len(x) <------将字符串的长度用作索引
> 一致 字符串的长度是固定的

## 应用场景
1. 用于查找，例如电话簿中联系人及电话号码之间可以建立映射关系，便于通过联系人查找到对应的电话号码。
2. 用于防止数据重复，例如投票时使用姓名建立散列表，并使用是否已投票作为值，这样可以有效地防止同一个人重复投票。
![截屏2022-09-23 16.42.59](assets/%E6%88%AA%E5%B1%8F2022-09-23%2016.42.59.png)


3. 用作缓存，例如网页中使用缓存策略，将URL与对应的内容进行映射，这样，当下次有人请求该URL时，你就可以直接发送缓存中的数据，而不用再让服务器进行处理了。

散列表适合用于：
* 模拟映射关系；
* 防止重复；
* 缓存/记住数据，以免服务器再通过处理来生成它们。

## 冲突
上面提到，散列函数总是将不同的键映射为不同的值，但实际上不是的。

当散列函数选的十分简单，如以键的首字母来分配数组位置时。如果有两个输入：apple和avocado，对于这个散列函数而言，他们的值是相同的，则他们在数组中的位置也将相同！

这种情况被称作冲突（collision）。在这种情况下，后被写入的键将覆盖前一个。则以后查询apple时，将得到的是avocado的值。

对于冲突的情况，最简单的解决方法是在冲突的位置存储一个链表，拓展这个散列表。

但当冲突的输入增多，链表增长后，散列表的速度将会变得很慢。

关于冲突我们需要记住下面两点经验教训：
* **散列函数很重要**。前面的散列函数将所有的键都映射到一个位置，而最理想的情况是，散列函数将键均匀地映射到散列表的不同位置。
* 如果散列表存储的链表很长，散列表的速度将急剧下降。然而，**如果使用的散列函数很好**，这些链表就不会很长！

## 性能
如果在散列表的冲突的位置，用链表进行缓解。在最糟情况下，散列表的所有操作的运行时间均为O(n)。
|操作|散列表（平均情况）|散列表（最糟情况）|数组|链表|
|------|------|------|------|------|
|查找|O(1)|O(n)|O(1)|O(n)|
|插入|O(1)|O(n)|O(n)|O(1)|
|删除|O(1)|O(n)|O(n)|O(1)|
因此，在使用散列表时，避开最糟情况至关重要。为此，需要避免冲突。
而要避免冲突，需要有：
* 较低的填装因子；
* 良好的散列函数。

## 填装因子
填装因子 = 散列表包含的元素个数 / 位置总数
例如，下述散列表的填装因子为2/5，即0.4。
![截屏2022-09-23 17.13.19](assets/%E6%88%AA%E5%B1%8F2022-09-23%2017.13.19.png)


一旦填装因子开始增大，你就需要在散列表中添加位置，这被称为调整长度（resizing）。
**填装因子越低，发生冲突的可能性越小，散列表的性能越高**。一个不错的经验规则是：一旦填装因子大于0.7，就调整散列表的长度。
调整散列表长度的工作需要很长时间！调整长度的开销很大，因此你不会希望频繁地这样做。但平均而言，即便考虑到调整长度所需的时间，散列表操作所需的时间也为O(1)。

**良好的散列函数让数组中的值呈均匀分布。**

## 练习二

散列函数的结果必须是均匀分布的，这很重要。它们的映射范围必须尽可能大。最糟糕的散列函数莫过于将所有输入都映射到散列表的同一个位置。
假设你有四个处理字符串的散列函数。
A. 不管输入是什么，都返回1。
B. 将字符串的长度用作索引。
C. 将字符串的第一个字符用作索引。即将所有以a打头的字符串都映射到散列表的同一个位置，以此类推。
D. 将每个字符都映射到一个素数：a = 2，b = 3，c = 5，d = 7，e = 11，等等。对于给定的字符串，这个散列函数将其中每个字符对应的素数相加，再计算结果除以散列表长度的余数。例如，如果散列表的长度为10，字符串为bag
 ，则索引为(3 + 2 + 17) % 10 = 22 % 10 = 2。
在下面的每个示例中，上述哪个散列函数可实现均匀分布？假设散列表的长度为10

5.5 将姓名和电话号码分别作为键和值的电话簿，其中联系人姓名为Esther、Ben、Bob和Dan。
> D

5.6 电池尺寸到功率的映射，其中电池尺寸为A、AA、AAA和AAAA。
> B、D

5.7 书名到作者的映射，其中书名分别为Maus、Fun Home和Watchmen。
> C、D

## 拓展与应用
[LeetCode 13. 罗马数字转整数](https://leetcode.cn/problems/roman-to-integer/)
罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

> 字符          数值
> I             1
> V             5
> X             10
> L             50
> C             100
> D             500
> M             1000

例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
 * I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
 * X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
 * C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。

示例 1:
> 输入: s = "III"
> 输出: 3

示例 2:
> 输入: s = "IV"
> 输出: 4

示例 3:
> 输入: s = "IX"
> 输出: 9

示例 4:
> 输入: s = "LVIII"
> 输出: 58
> 解释: L = 50, V= 5, III = 3.

示例 5:
> 输入: s = "MCMXCIV"
> 输出: 1994
> 解释: M = 1000, CM = 900, XC = 90, IV = 4.
 

提示：

* 1 <= s.length <= 15
* s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M')
* 题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内
* 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。
* IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。
* 关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。

这里可以使用字典（散列表）建立映射关系，在根据字符与数字之间的关系，计算出罗马字符代表的值。
```
class Solution {
    func romanToInt(_ s: String) -> Int {
    
    var dic: [Character: Int] = ["I": 1, "V": 5, "X": 10, "L": 50, "C": 100, "D": 500, "M": 1000]
    var num = 0
    for (index, char) in s.enumerated() {
        let value = dic[char]
        if value == nil {
            fatalError("不是罗马字符 \(char)")
        }
        
        if index + 1 < s.count {
            if let next = dic[s[s.index(s.startIndex, offsetBy: index + 1)] as Character] {
                if next > value! {
                    num -= value!
                } else {
                    num += value!
                }
            } else {
                fatalError("不是罗马字符")
            }
        } else {
            num += value! 
        }
    }
    return num
}
}
```